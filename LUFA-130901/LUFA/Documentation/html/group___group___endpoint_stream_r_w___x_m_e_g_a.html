<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>LUFA Library: Read/Write of Multi-Byte Streams (XMEGA)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="Style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="LUFA_thumb.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">LUFA Library
   &#160;<span id="projectnumber">130901</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___group___endpoint_stream_r_w___x_m_e_g_a.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Read/Write of Multi-Byte Streams (XMEGA)<div class="ingroups"><a class="el" href="group___group___endpoint_stream_r_w.html">Read/Write of Multi-Byte Streams</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Endpoint data stream transmission and reception management for the Atmel AVR XMEGA architecture.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Stream functions for null data</h2></td></tr>
<tr class="memitem:gaa829c209690100243e9b32e7261cb51b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#gaa829c209690100243e9b32e7261cb51b">Endpoint_Discard_Stream</a> (uint16_t Length, uint16_t *const BytesProcessed)</td></tr>
<tr class="separator:gaa829c209690100243e9b32e7261cb51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9903cea1df4be871aeb29cb6224503f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#gab9903cea1df4be871aeb29cb6224503f">Endpoint_Null_Stream</a> (uint16_t Length, uint16_t *const BytesProcessed)</td></tr>
<tr class="separator:gab9903cea1df4be871aeb29cb6224503f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Stream functions for RAM source/destination data</h2></td></tr>
<tr class="memitem:ga1373965e66df66877ae7bd8b6191fa48"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#ga1373965e66df66877ae7bd8b6191fa48">Endpoint_Write_Stream_LE</a> (const void *const Buffer, uint16_t Length, uint16_t *const BytesProcessed) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:ga1373965e66df66877ae7bd8b6191fa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c206c46b1acf417b475d45fbaeb0c8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#ga17c206c46b1acf417b475d45fbaeb0c8">Endpoint_Write_Stream_BE</a> (const void *const Buffer, uint16_t Length, uint16_t *const BytesProcessed) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:ga17c206c46b1acf417b475d45fbaeb0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga583da8b69e4c4cea7946f6304b338668"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#ga583da8b69e4c4cea7946f6304b338668">Endpoint_Read_Stream_LE</a> (void *const Buffer, uint16_t Length, uint16_t *const BytesProcessed) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:ga583da8b69e4c4cea7946f6304b338668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb69bac6c0d227d1cfaac4bc7d2e27b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#ga1eb69bac6c0d227d1cfaac4bc7d2e27b">Endpoint_Read_Stream_BE</a> (void *const Buffer, uint16_t Length, uint16_t *const BytesProcessed) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:ga1eb69bac6c0d227d1cfaac4bc7d2e27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeceef4513a67715fd2495af93f3a06a8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#gaeceef4513a67715fd2495af93f3a06a8">Endpoint_Write_Control_Stream_LE</a> (const void *const Buffer, uint16_t Length) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:gaeceef4513a67715fd2495af93f3a06a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44a3ada1925d23f5fd30a725e92b941"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#gae44a3ada1925d23f5fd30a725e92b941">Endpoint_Write_Control_Stream_BE</a> (const void *const Buffer, uint16_t Length) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:gae44a3ada1925d23f5fd30a725e92b941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7c090a3b16c980884bda08957dff760"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#gad7c090a3b16c980884bda08957dff760">Endpoint_Read_Control_Stream_LE</a> (void *const Buffer, uint16_t Length) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:gad7c090a3b16c980884bda08957dff760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga115cef51e68d6f0f2665cd825f92e526"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#ga115cef51e68d6f0f2665cd825f92e526">Endpoint_Read_Control_Stream_BE</a> (void *const Buffer, uint16_t Length) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:ga115cef51e68d6f0f2665cd825f92e526"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Stream functions for EEPROM source/destination data</h2></td></tr>
<tr class="memitem:gaa0da2ddefe8f3dd074239ea06f3f36dd"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#gaa0da2ddefe8f3dd074239ea06f3f36dd">Endpoint_Write_EStream_LE</a> (const void *const Buffer, uint16_t Length, uint16_t *const BytesProcessed) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:gaa0da2ddefe8f3dd074239ea06f3f36dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7d169869bfee44aaaa486746d164e21"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#gac7d169869bfee44aaaa486746d164e21">Endpoint_Write_EStream_BE</a> (const void *const Buffer, uint16_t Length, uint16_t *const BytesProcessed) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:gac7d169869bfee44aaaa486746d164e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4179cb6d30a02a54140f5c955274e3a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#gae4179cb6d30a02a54140f5c955274e3a">Endpoint_Read_EStream_LE</a> (void *const Buffer, uint16_t Length, uint16_t *const BytesProcessed) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:gae4179cb6d30a02a54140f5c955274e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9579c24ee43db737e21e6409f194126e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#ga9579c24ee43db737e21e6409f194126e">Endpoint_Read_EStream_BE</a> (void *const Buffer, uint16_t Length, uint16_t *const BytesProcessed) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:ga9579c24ee43db737e21e6409f194126e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc501d62857000764b03ac63d5e079b4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#gabc501d62857000764b03ac63d5e079b4">Endpoint_Write_Control_EStream_LE</a> (const void *const Buffer, uint16_t Length) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:gabc501d62857000764b03ac63d5e079b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a9332efe9b8850d943c1b6a602f5d7d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#ga5a9332efe9b8850d943c1b6a602f5d7d">Endpoint_Write_Control_EStream_BE</a> (const void *const Buffer, uint16_t Length) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:ga5a9332efe9b8850d943c1b6a602f5d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a85851154bfb7aca602e5f575e888c5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#ga8a85851154bfb7aca602e5f575e888c5">Endpoint_Read_Control_EStream_LE</a> (void *const Buffer, uint16_t Length) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:ga8a85851154bfb7aca602e5f575e888c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff111cba1aa09cd1095c33d8bf8028d5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#gaff111cba1aa09cd1095c33d8bf8028d5">Endpoint_Read_Control_EStream_BE</a> (void *const Buffer, uint16_t Length) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:gaff111cba1aa09cd1095c33d8bf8028d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Stream functions for PROGMEM source/destination data</h2></td></tr>
<tr class="memitem:ga0b7278d142151babd472a1d56a8fd153"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#ga0b7278d142151babd472a1d56a8fd153">Endpoint_Write_PStream_LE</a> (const void *const Buffer, uint16_t Length, uint16_t *const BytesProcessed) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:ga0b7278d142151babd472a1d56a8fd153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ffd09d6bf0604ff04db62a4454d4ed3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#ga3ffd09d6bf0604ff04db62a4454d4ed3">Endpoint_Write_PStream_BE</a> (const void *const Buffer, uint16_t Length, uint16_t *const BytesProcessed) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:ga3ffd09d6bf0604ff04db62a4454d4ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8dc9186992b8bab4b59ad4827742849"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#gad8dc9186992b8bab4b59ad4827742849">Endpoint_Write_Control_PStream_LE</a> (const void *const Buffer, uint16_t Length) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:gad8dc9186992b8bab4b59ad4827742849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a70911499ee6e483147f3282f1de81"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_stream_r_w___x_m_e_g_a.html#ga79a70911499ee6e483147f3282f1de81">Endpoint_Write_Control_PStream_BE</a> (const void *const Buffer, uint16_t Length) <a class="el" href="group___group___func_var_attributes.html#ga6cab2758ec5d666d8b4542b09102f106">ATTR_NON_NULL_PTR_ARG</a>(1)</td></tr>
<tr class="separator:ga79a70911499ee6e483147f3282f1de81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions, macros, variables, enums and types related to data reading and writing of data streams from and to endpoints. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa829c209690100243e9b32e7261cb51b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Discard_Stream </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads and discards the given number of bytes from the currently selected endpoint's bank, discarding fully read packets from the host as needed. The last packet is not automatically discarded once the remaining bytes has been read; the user is responsible for manually discarding the last packet from the host via the <a class="el" href="group___group___endpoint_packet_management___a_v_r8.html#gaaa540fdeeab01f675617d210c1ac4eb3">Endpoint_ClearOUT()</a> macro.</p>
<p>If the BytesProcessed parameter is <code>NULL</code>, the entire stream transfer is attempted at once, failing or succeeding as a single unit. If the BytesProcessed parameter points to a valid storage location, the transfer will instead be performed as a series of chunks. Each time the endpoint bank becomes empty while there is still data to process (and after the current packet has been acknowledged) the BytesProcessed location will be updated with the total number of bytes processed in the stream, and the function will exit with an error code of <a class="el" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba68d6046a48e8819b824013c937f9acdf">ENDPOINT_RWSTREAM_IncompleteTransfer</a>. This allows for any abort checking to be performed in the user code - to continue the transfer, call the function again with identical parameters and it will resume until the BytesProcessed value reaches the total transfer length.</p>
<p><b>Single Stream Transfer Example:</b> </p>
<div class="fragment"><div class="line">uint8_t ErrorCode;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> ((ErrorCode = <a class="code" href="group___group___endpoint_stream_r_w___a_v_r8.html#gaa829c209690100243e9b32e7261cb51b">Endpoint_Discard_Stream</a>(512, NULL)) != <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba6acf368d991bdd879f9ca07f728b5e7d">ENDPOINT_RWSTREAM_NoError</a>)</div>
<div class="line">{</div>
<div class="line">     <span class="comment">// Stream failed to complete - check ErrorCode here</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Partial Stream Transfers Example:</b> </p>
<div class="fragment"><div class="line">uint8_t  ErrorCode;</div>
<div class="line">uint16_t BytesProcessed;</div>
<div class="line"></div>
<div class="line">BytesProcessed = 0;</div>
<div class="line"><span class="keywordflow">while</span> ((ErrorCode = <a class="code" href="group___group___endpoint_stream_r_w___a_v_r8.html#gaa829c209690100243e9b32e7261cb51b">Endpoint_Discard_Stream</a>(512, &amp;BytesProcessed)) == <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba68d6046a48e8819b824013c937f9acdf">ENDPOINT_RWSTREAM_IncompleteTransfer</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Stream not yet complete - do other actions here, abort if required</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (ErrorCode != <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba6acf368d991bdd879f9ca07f728b5e7d">ENDPOINT_RWSTREAM_NoError</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Stream failed to complete - check ErrorCode here</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to discard via the currently selected endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be read at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gab9903cea1df4be871aeb29cb6224503f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Null_Stream </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a given number of zeroed bytes to the currently selected endpoint's bank, sending full packets to the host as needed. The last packet is not automatically sent once the remaining bytes have been written; the user is responsible for manually sending the last packet to the host via the <a class="el" href="group___group___endpoint_packet_management___a_v_r8.html#gaa03a298562e0a76d3095c9edf7eeecd5">Endpoint_ClearIN()</a> macro.</p>
<p>If the BytesProcessed parameter is <code>NULL</code>, the entire stream transfer is attempted at once, failing or succeeding as a single unit. If the BytesProcessed parameter points to a valid storage location, the transfer will instead be performed as a series of chunks. Each time the endpoint bank becomes full while there is still data to process (and after the current packet transmission has been initiated) the BytesProcessed location will be updated with the total number of bytes processed in the stream, and the function will exit with an error code of <a class="el" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba68d6046a48e8819b824013c937f9acdf">ENDPOINT_RWSTREAM_IncompleteTransfer</a>. This allows for any abort checking to be performed in the user code - to continue the transfer, call the function again with identical parameters and it will resume until the BytesProcessed value reaches the total transfer length.</p>
<p><b>Single Stream Transfer Example:</b> </p>
<div class="fragment"><div class="line">uint8_t ErrorCode;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> ((ErrorCode = <a class="code" href="group___group___endpoint_stream_r_w___a_v_r8.html#gab9903cea1df4be871aeb29cb6224503f">Endpoint_Null_Stream</a>(512, NULL)) != <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba6acf368d991bdd879f9ca07f728b5e7d">ENDPOINT_RWSTREAM_NoError</a>)</div>
<div class="line">{</div>
<div class="line">     <span class="comment">// Stream failed to complete - check ErrorCode here</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Partial Stream Transfers Example:</b> </p>
<div class="fragment"><div class="line">uint8_t  ErrorCode;</div>
<div class="line">uint16_t BytesProcessed;</div>
<div class="line"></div>
<div class="line">BytesProcessed = 0;</div>
<div class="line"><span class="keywordflow">while</span> ((ErrorCode = <a class="code" href="group___group___endpoint_stream_r_w___a_v_r8.html#gab9903cea1df4be871aeb29cb6224503f">Endpoint_Null_Stream</a>(512, &amp;BytesProcessed)) == <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba68d6046a48e8819b824013c937f9acdf">ENDPOINT_RWSTREAM_IncompleteTransfer</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Stream not yet complete - do other actions here, abort if required</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (ErrorCode != <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba6acf368d991bdd879f9ca07f728b5e7d">ENDPOINT_RWSTREAM_NoError</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Stream failed to complete - check ErrorCode here</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of zero bytes to send via the currently selected endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be read at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff111cba1aa09cd1095c33d8bf8028d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Control_EStream_BE </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="group___group___endpoint_stream_r_w___a_v_r8.html#ga115cef51e68d6f0f2665cd825f92e526">Endpoint_Read_Control_Stream_BE()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function automatically sends the last packet in the data stage of the transaction; when the function returns, the user is responsible for clearing the <b>status</b> stage of the transaction. Note that the status stage packet is sent or received in the opposite direction of the data flow. <br/>
<br/>
</dd>
<dd>
This routine should only be used on CONTROL type endpoints. <br/>
<br/>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to send via the currently selected endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a85851154bfb7aca602e5f575e888c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Control_EStream_LE </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="group___group___endpoint_stream_r_w___a_v_r8.html#gad7c090a3b16c980884bda08957dff760">Endpoint_Read_Control_Stream_LE()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function automatically sends the last packet in the data stage of the transaction; when the function returns, the user is responsible for clearing the <b>status</b> stage of the transaction. Note that the status stage packet is sent or received in the opposite direction of the data flow. <br/>
<br/>
</dd>
<dd>
This routine should only be used on CONTROL type endpoints. <br/>
<br/>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to send via the currently selected endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga115cef51e68d6f0f2665cd825f92e526"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Control_Stream_BE </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the given number of bytes from the CONTROL endpoint from the given buffer in big endian, discarding fully read packets from the host as needed. The device IN acknowledgement is not automatically sent after success or failure states; the user is responsible for manually sending the status IN packet to finalize the transfer's status stage via the <a class="el" href="group___group___endpoint_packet_management___a_v_r8.html#gaa03a298562e0a76d3095c9edf7eeecd5">Endpoint_ClearIN()</a> macro.</p>
<dl class="section note"><dt>Note</dt><dd>This function automatically sends the last packet in the data stage of the transaction; when the function returns, the user is responsible for clearing the <b>status</b> stage of the transaction. Note that the status stage packet is sent or received in the opposite direction of the data flow. <br/>
<br/>
</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to send via the currently selected endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gad7c090a3b16c980884bda08957dff760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Control_Stream_LE </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the given number of bytes from the CONTROL endpoint from the given buffer in little endian, discarding fully read packets from the host as needed. The device IN acknowledgement is not automatically sent after success or failure states; the user is responsible for manually sending the status IN packet to finalize the transfer's status stage via the <a class="el" href="group___group___endpoint_packet_management___a_v_r8.html#gaa03a298562e0a76d3095c9edf7eeecd5">Endpoint_ClearIN()</a> macro.</p>
<dl class="section note"><dt>Note</dt><dd>This function automatically sends the last packet in the data stage of the transaction; when the function returns, the user is responsible for clearing the <b>status</b> stage of the transaction. Note that the status stage packet is sent or received in the opposite direction of the data flow. <br/>
<br/>
</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to send via the currently selected endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9579c24ee43db737e21e6409f194126e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_EStream_BE </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EEPROM buffer destination version of <a class="el" href="group___group___endpoint_stream_r_w___a_v_r8.html#ga1eb69bac6c0d227d1cfaac4bc7d2e27b">Endpoint_Read_Stream_BE()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the destination data buffer to write to, located in EEPROM memory space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be read at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gae4179cb6d30a02a54140f5c955274e3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_EStream_LE </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EEPROM buffer destination version of <a class="el" href="group___group___endpoint_stream_r_w___a_v_r8.html#ga583da8b69e4c4cea7946f6304b338668">Endpoint_Read_Stream_LE()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the destination data buffer to write to, located in EEPROM memory space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be read at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1eb69bac6c0d227d1cfaac4bc7d2e27b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Stream_BE </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the given number of bytes from the endpoint from the given buffer in big endian, discarding fully read packets from the host as needed. The last packet is not automatically discarded once the remaining bytes has been read; the user is responsible for manually discarding the last packet from the host via the <a class="el" href="group___group___endpoint_packet_management___a_v_r8.html#gaaa540fdeeab01f675617d210c1ac4eb3">Endpoint_ClearOUT()</a> macro.</p>
<dl class="section note"><dt>Note</dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be read at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga583da8b69e4c4cea7946f6304b338668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Stream_LE </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the given number of bytes from the endpoint from the given buffer in little endian, discarding fully read packets from the host as needed. The last packet is not automatically discarded once the remaining bytes has been read; the user is responsible for manually discarding the last packet from the host via the <a class="el" href="group___group___endpoint_packet_management___a_v_r8.html#gaaa540fdeeab01f675617d210c1ac4eb3">Endpoint_ClearOUT()</a> macro.</p>
<p>If the BytesProcessed parameter is <code>NULL</code>, the entire stream transfer is attempted at once, failing or succeeding as a single unit. If the BytesProcessed parameter points to a valid storage location, the transfer will instead be performed as a series of chunks. Each time the endpoint bank becomes empty while there is still data to process (and after the current packet has been acknowledged) the BytesProcessed location will be updated with the total number of bytes processed in the stream, and the function will exit with an error code of <a class="el" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba68d6046a48e8819b824013c937f9acdf">ENDPOINT_RWSTREAM_IncompleteTransfer</a>. This allows for any abort checking to be performed in the user code - to continue the transfer, call the function again with identical parameters and it will resume until the BytesProcessed value reaches the total transfer length.</p>
<p><b>Single Stream Transfer Example:</b> </p>
<div class="fragment"><div class="line">uint8_t DataStream[512];</div>
<div class="line">uint8_t ErrorCode;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> ((ErrorCode = <a class="code" href="group___group___endpoint_stream_r_w___a_v_r8.html#ga583da8b69e4c4cea7946f6304b338668">Endpoint_Read_Stream_LE</a>(DataStream, <span class="keyword">sizeof</span>(DataStream),</div>
<div class="line">                                         NULL)) != <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba6acf368d991bdd879f9ca07f728b5e7d">ENDPOINT_RWSTREAM_NoError</a>)</div>
<div class="line">{</div>
<div class="line">     <span class="comment">// Stream failed to complete - check ErrorCode here</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Partial Stream Transfers Example:</b> </p>
<div class="fragment"><div class="line">uint8_t  DataStream[512];</div>
<div class="line">uint8_t  ErrorCode;</div>
<div class="line">uint16_t BytesProcessed;</div>
<div class="line"></div>
<div class="line">BytesProcessed = 0;</div>
<div class="line"><span class="keywordflow">while</span> ((ErrorCode = <a class="code" href="group___group___endpoint_stream_r_w___a_v_r8.html#ga583da8b69e4c4cea7946f6304b338668">Endpoint_Read_Stream_LE</a>(DataStream, <span class="keyword">sizeof</span>(DataStream),</div>
<div class="line">                                            &amp;BytesProcessed)) == <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba68d6046a48e8819b824013c937f9acdf">ENDPOINT_RWSTREAM_IncompleteTransfer</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Stream not yet complete - do other actions here, abort if required</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (ErrorCode != <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba6acf368d991bdd879f9ca07f728b5e7d">ENDPOINT_RWSTREAM_NoError</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Stream failed to complete - check ErrorCode here</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be read at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a9332efe9b8850d943c1b6a602f5d7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_EStream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="group___group___endpoint_stream_r_w___a_v_r8.html#gae44a3ada1925d23f5fd30a725e92b941">Endpoint_Write_Control_Stream_BE()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function automatically sends the last packet in the data stage of the transaction; when the function returns, the user is responsible for clearing the <b>status</b> stage of the transaction. Note that the status stage packet is sent or received in the opposite direction of the data flow. <br/>
<br/>
</dd>
<dd>
This routine should only be used on CONTROL type endpoints. <br/>
<br/>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gabc501d62857000764b03ac63d5e079b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_EStream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EEPROM buffer source version of Endpoint_Write_Control_Stream_LE.</p>
<dl class="section note"><dt>Note</dt><dd>This function automatically sends the last packet in the data stage of the transaction; when the function returns, the user is responsible for clearing the <b>status</b> stage of the transaction. Note that the status stage packet is sent or received in the opposite direction of the data flow. <br/>
<br/>
</dd>
<dd>
This routine should only be used on CONTROL type endpoints. <br/>
<br/>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga79a70911499ee6e483147f3282f1de81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_PStream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FLASH buffer source version of <a class="el" href="group___group___endpoint_stream_r_w___a_v_r8.html#gae44a3ada1925d23f5fd30a725e92b941">Endpoint_Write_Control_Stream_BE()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The FLASH data must be located in the first 64KB of FLASH for this function to work correctly.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function automatically sends the last packet in the data stage of the transaction; when the function returns, the user is responsible for clearing the <b>status</b> stage of the transaction. Note that the status stage packet is sent or received in the opposite direction of the data flow. <br/>
<br/>
</dd>
<dd>
This routine should only be used on CONTROL type endpoints. <br/>
<br/>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gad8dc9186992b8bab4b59ad4827742849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_PStream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FLASH buffer source version of <a class="el" href="group___group___endpoint_stream_r_w___a_v_r8.html#gaeceef4513a67715fd2495af93f3a06a8">Endpoint_Write_Control_Stream_LE()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The FLASH data must be located in the first 64KB of FLASH for this function to work correctly.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function automatically sends the last packet in the data stage of the transaction; when the function returns, the user is responsible for clearing the <b>status</b> stage of the transaction. Note that the status stage packet is sent or received in the opposite direction of the data flow. <br/>
<br/>
</dd>
<dd>
This routine should only be used on CONTROL type endpoints. <br/>
<br/>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gae44a3ada1925d23f5fd30a725e92b941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_Stream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the given number of bytes to the CONTROL type endpoint from the given buffer in big endian, sending full packets to the host as needed. The host OUT acknowledgement is not automatically cleared in both failure and success states; the user is responsible for manually clearing the status OUT packet to finalize the transfer's status stage via the <a class="el" href="group___group___endpoint_packet_management___a_v_r8.html#gaaa540fdeeab01f675617d210c1ac4eb3">Endpoint_ClearOUT()</a> macro.</p>
<dl class="section note"><dt>Note</dt><dd>This function automatically sends the last packet in the data stage of the transaction; when the function returns, the user is responsible for clearing the <b>status</b> stage of the transaction. Note that the status stage packet is sent or received in the opposite direction of the data flow. <br/>
<br/>
</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeceef4513a67715fd2495af93f3a06a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_Stream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the given number of bytes to the CONTROL type endpoint from the given buffer in little endian, sending full packets to the host as needed. The host OUT acknowledgement is not automatically cleared in both failure and success states; the user is responsible for manually clearing the status OUT packet to finalize the transfer's status stage via the <a class="el" href="group___group___endpoint_packet_management___a_v_r8.html#gaaa540fdeeab01f675617d210c1ac4eb3">Endpoint_ClearOUT()</a> macro.</p>
<dl class="section note"><dt>Note</dt><dd>This function automatically sends the last packet in the data stage of the transaction; when the function returns, the user is responsible for clearing the <b>status</b> stage of the transaction. Note that the status stage packet is sent or received in the opposite direction of the data flow. <br/>
<br/>
</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gac7d169869bfee44aaaa486746d164e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_EStream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="group___group___endpoint_stream_r_w___a_v_r8.html#ga17c206c46b1acf417b475d45fbaeb0c8">Endpoint_Write_Stream_BE()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be written at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0da2ddefe8f3dd074239ea06f3f36dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_EStream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="group___group___endpoint_stream_r_w___a_v_r8.html#ga1373965e66df66877ae7bd8b6191fa48">Endpoint_Write_Stream_LE()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be written at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ffd09d6bf0604ff04db62a4454d4ed3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_PStream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FLASH buffer source version of <a class="el" href="group___group___endpoint_stream_r_w___a_v_r8.html#ga17c206c46b1acf417b475d45fbaeb0c8">Endpoint_Write_Stream_BE()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The FLASH data must be located in the first 64KB of FLASH for this function to work correctly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be written at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b7278d142151babd472a1d56a8fd153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_PStream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FLASH buffer source version of <a class="el" href="group___group___endpoint_stream_r_w___a_v_r8.html#ga1373965e66df66877ae7bd8b6191fa48">Endpoint_Write_Stream_LE()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The FLASH data must be located in the first 64KB of FLASH for this function to work correctly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be written at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga17c206c46b1acf417b475d45fbaeb0c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Stream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the given number of bytes to the endpoint from the given buffer in big endian, sending full packets to the host as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="group___group___endpoint_packet_management___a_v_r8.html#gaa03a298562e0a76d3095c9edf7eeecd5">Endpoint_ClearIN()</a> macro.</p>
<dl class="section note"><dt>Note</dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be written at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1373965e66df66877ae7bd8b6191fa48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Stream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>BytesProcessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the given number of bytes to the endpoint from the given buffer in little endian, sending full packets to the host as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="group___group___endpoint_packet_management___a_v_r8.html#gaa03a298562e0a76d3095c9edf7eeecd5">Endpoint_ClearIN()</a> macro.</p>
<p>If the BytesProcessed parameter is <code>NULL</code>, the entire stream transfer is attempted at once, failing or succeeding as a single unit. If the BytesProcessed parameter points to a valid storage location, the transfer will instead be performed as a series of chunks. Each time the endpoint bank becomes full while there is still data to process (and after the current packet transmission has been initiated) the BytesProcessed location will be updated with the total number of bytes processed in the stream, and the function will exit with an error code of <a class="el" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba68d6046a48e8819b824013c937f9acdf">ENDPOINT_RWSTREAM_IncompleteTransfer</a>. This allows for any abort checking to be performed in the user code - to continue the transfer, call the function again with identical parameters and it will resume until the BytesProcessed value reaches the total transfer length.</p>
<p><b>Single Stream Transfer Example:</b> </p>
<div class="fragment"><div class="line">uint8_t DataStream[512];</div>
<div class="line">uint8_t ErrorCode;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> ((ErrorCode = <a class="code" href="group___group___endpoint_stream_r_w___a_v_r8.html#ga1373965e66df66877ae7bd8b6191fa48">Endpoint_Write_Stream_LE</a>(DataStream, <span class="keyword">sizeof</span>(DataStream),</div>
<div class="line">                                          NULL)) != <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba6acf368d991bdd879f9ca07f728b5e7d">ENDPOINT_RWSTREAM_NoError</a>)</div>
<div class="line">{</div>
<div class="line">     <span class="comment">// Stream failed to complete - check ErrorCode here</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Partial Stream Transfers Example:</b> </p>
<div class="fragment"><div class="line">uint8_t  DataStream[512];</div>
<div class="line">uint8_t  ErrorCode;</div>
<div class="line">uint16_t BytesProcessed;</div>
<div class="line"></div>
<div class="line">BytesProcessed = 0;</div>
<div class="line"><span class="keywordflow">while</span> ((ErrorCode = <a class="code" href="group___group___endpoint_stream_r_w___a_v_r8.html#ga1373965e66df66877ae7bd8b6191fa48">Endpoint_Write_Stream_LE</a>(DataStream, <span class="keyword">sizeof</span>(DataStream),</div>
<div class="line">                                             &amp;BytesProcessed)) == <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba68d6046a48e8819b824013c937f9acdf">ENDPOINT_RWSTREAM_IncompleteTransfer</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Stream not yet complete - do other actions here, abort if required</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (ErrorCode != <a class="code" href="group___group___endpoint_stream_r_w.html#gga7f0d584afdd478f8fdf20b9daf58394ba6acf368d991bdd879f9ca07f728b5e7d">ENDPOINT_RWSTREAM_NoError</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Stream failed to complete - check ErrorCode here</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesProcessed</td><td>Pointer to a location where the total number of bytes processed in the current transaction should be updated, <code>NULL</code> if the entire stream should be written at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the <a class="el" href="group___group___endpoint_stream_r_w.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
		<ul>
			<li class="footer" style="float:left !important;">
				Generated by
				<a href="http://www.doxygen.org/index.html">
					<img class="footer" src="doxygen.png" alt="doxygen"/>
				</a>
				1.8.3.1
			</li>
			<li class="footer">
				<a href="http://www.lufa-lib.org" title="LUFA Project Page">LUFA Project Page</a> | <a href="http://www.lufa-lib.org/support" title="LUFA Support List">Support Mailing List</a> | <a href="http://www.lufa-lib.org/donate" title="Donate to Support LUFA">Donate</a> | <a href="http://www.fourwalledcubicle.com" title="Four Walled Cubicle Website">Four Walled Cubicle</a> - LUFA, the Lightweight USB Framework for AVRs
			</li>
		</ul>
	</div>
	</body>
</html>
