<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>LUFA Library: Summary of Compile Tokens</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="Style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="LUFA_thumb.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">LUFA Library
   &#160;<span id="projectnumber">130901</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_page__token_summary.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Summary of Compile Tokens </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The following lists all the possible tokens which can be defined in a project makefile, and passed to the compiler via the -D switch, to alter the LUFA library code. These tokens may alter the library behaviour, or remove features unused by a given application in order to save flash space.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>USE_LUFA_CONFIG_HEADER</code> token is defined, the library will include a header file named <code><a class="el" href="_l_u_f_a_config_8h.html" title="LUFA Library Configuration Header File (Template)">LUFAConfig.h</a></code> located in the user directory where the below compile time tokens may be defined. This allows for an alternative to makefile defined tokens for configuring the library.</dd></dl>
<h1><a class="anchor" id="Sec_TokenSummary_NonUSBTokens"></a>
Non USB Related Tokens</h1>
<p>This section describes compile tokens which affect non-USB sections of the LUFA library.</p>
<ul>
<li><b>DISABLE_TERMINAL_CODES</b> - (<a class="el" href="group___group___terminal.html">ANSI Terminal Escape Codes - LUFA/Drivers/Misc/TerminalCodes.h</a>) - <em>All Architectures</em> <br/>
 If an application contains ANSI terminal control codes listed in <a class="el" href="_terminal_codes_8h.html" title="ANSI terminal special escape code macros.">TerminalCodes.h</a>, it might be desired to remove them at compile time for use with a terminal which is non-ANSI control code aware, without modifying the source code. If this token is defined, all ANSI control codes in the application code from the <a class="el" href="_terminal_codes_8h.html" title="ANSI terminal special escape code macros.">TerminalCodes.h</a> header are removed from the source code at compile time.</li>
</ul>
<h1><a class="anchor" id="Sec_TokenSummary_USBClassTokens"></a>
USB Class Driver Related Tokens</h1>
<p>This section describes compile tokens which affect USB class-specific drivers in the LUFA library.</p>
<ul>
<li><b>HID_HOST_BOOT_PROTOCOL_ONLY</b> - (<a class="el" href="group___group___u_s_b_class_h_i_d_host.html">HID Class Host Mode Driver</a>) - <em>All Architectures</em> <br/>
 By default, the USB HID Host class driver is designed to work with HID devices using either the Boot or Report HID communication protocols. On devices where the Report protocol is not used (i.e. in applications where only basic Mouse or Keyboard operation is desired, using boot compatible devices), the code responsible for the Report protocol mode can be removed to save space in the compiled application by defining this token. When defined, it is still necessary to explicitly put the attached device into Boot protocol mode via a call to <a class="el" href="group___group___u_s_b_class_h_i_d_host.html#ga3ff69d38732ff6df8df69342e78df86f">HID_Host_SetBootProtocol()</a>.</li>
</ul>
<ul>
<li><b>HID_STATETABLE_STACK_DEPTH</b>=<em>x</em> - (<a class="el" href="group___group___h_i_d_parser.html">HID Report Parser</a>) - <em>All Architectures</em> <br/>
 HID reports may contain PUSH and POP elements, to store and retrieve the current HID state table onto a stack. This allows for reports to save the state table before modifying it slightly for a data item, and then restore the previous state table in a compact manner. This token may be defined to a non-zero 8-bit value to give the maximum depth of the state table stack. If not defined, this defaults to the value indicated in the HID.h file documentation.</li>
</ul>
<ul>
<li><b>HID_USAGE_STACK_DEPTH</b>=<em>x</em> - (<a class="el" href="group___group___h_i_d_parser.html">HID Report Parser</a>) - <em>All Architectures</em> <br/>
 HID reports generally contain many USAGE elements, which are assigned to INPUT, OUTPUT and FEATURE items in succession when multiple items are defined at once (via REPORT COUNT elements). This allows for several items to be defined with different usages in a compact manner. This token may be defined to a non-zero 8-bit value to set the maximum depth of the usage stack, indicating the maximum number of USAGE items which can be stored temporarily until the next INPUT, OUTPUT and FEATURE item. If not defined, this defaults to the value indicated in the HID.h file documentation.</li>
</ul>
<ul>
<li><b>HID_MAX_COLLECTIONS</b>=<em>x</em> - (<a class="el" href="group___group___h_i_d_parser.html">HID Report Parser</a>) - <em>All Architectures</em> <br/>
 HID reports generally contain several COLLECTION elements, used to group related data items together. Collection information is stored separately in the processed usage structure (and referred to by the data elements in the structure) to save space. This token may be defined to a non-zero 8-bit value to set the maximum number of COLLECTION items which can be processed by the parser into the resultant processed report structure. If not defined, this defaults to the value indicated in the HID.h file documentation.</li>
</ul>
<ul>
<li><b>HID_MAX_REPORTITEMS</b>=<em>x</em> - (<a class="el" href="group___group___h_i_d_parser.html">HID Report Parser</a>) - <em>All Architectures</em> <br/>
 All HID reports contain one or more INPUT, OUTPUT and/or FEATURE items describing the data which can be sent to and from the HID device. Each item has associated usages, bit offsets in the item reports and other associated data indicating the manner in which the report data should be interpreted by the host. This token may be defined to a non-zero 8-bit value to set the maximum number of data elements which can be stored in the processed HID report structure, including INPUT, OUTPUT and (if enabled) FEATURE items. If a item has a multiple count (i.e. a REPORT COUNT of more than 1), each item in the report count is placed separately in the processed HID report table. If not defined, this defaults to the value indicated in the HID.h file documentation.</li>
</ul>
<ul>
<li><b>HID_MAX_REPORT_IDS</b>=<em>x</em> - (<a class="el" href="group___group___h_i_d_parser.html">HID Report Parser</a>) - <em>All Architectures</em> <br/>
 HID reports may contain several report IDs, to logically distinguish grouped device data from one another - for example, a combination keyboard and mouse might use report IDs to separate the keyboard reports from the mouse reports. In order to determine the size of each report, and thus know how many bytes must be read or written, the size of each report (IN, OUT and FEATURE) must be calculated and stored. This token may be defined to a non-zero 8-bit value to set the maximum number of report IDs in a device which can be processed and their sizes calculated/stored into the resultant processed report structure. If not defined, this defaults to the value indicated in the HID.h file documentation.</li>
</ul>
<ul>
<li><b>NO_CLASS_DRIVER_AUTOFLUSH</b> - (<a class="el" href="group___group___u_s_b_class_drivers.html">USB Class Drivers</a>) - <em>All Architectures</em> <br/>
 Many of the device and host mode class drivers automatically flush any data waiting to be written to an interface, when the corresponding USB management task is executed. This is usually desirable to ensure that any queued data is sent as soon as possible once and new data is constructed in the main program loop. However, if flushing is to be controlled manually by the user application via the *_Flush() commands, the compile time token may be defined in the application's makefile to disable automatic flushing during calls to the class driver USB management tasks.</li>
</ul>
<h1><a class="anchor" id="Sec_TokenSummary_USBTokens"></a>
General USB Driver Related Tokens</h1>
<p>This section describes compile tokens which affect USB driver stack as a whole in the LUFA library.</p>
<ul>
<li><b>ORDERED_EP_CONFIG</b> - (<a class="el" href="group___group___endpoint_management.html">Endpoint Management</a> , <a class="el" href="group___group___pipe_management.html">Pipe Management</a>) - <em>AVR8, UC3</em> <br/>
 The USB AVRs do not allow for Endpoints and Pipes to be configured out of order; they <em>must</em> be configured in an ascending order to prevent data corruption issues. However, by default LUFA employs a workaround to allow for unordered Endpoint/Pipe initialization. This compile time token may be used to restrict the initialization order to ascending indexes only in exchange for a smaller compiled binary size. Use caution when applied to applications using the library USB Class drivers; the user application must ensure that all endpoints and pipes are allocated sequentially.</li>
</ul>
<ul>
<li><b>USE_STATIC_OPTIONS</b>=<em>x</em> - (<a class="el" href="group___group___u_s_b_management.html">USB Interface Management</a>) - <em>All Architectures</em> <br/>
 By default, the <a class="el" href="group___group___u_s_b_management___a_v_r8.html#gaa6fa034a919f41e17908bdcd7d5ae151">USB_Init()</a> function accepts dynamic options at runtime to alter the library behaviour, including whether the USB pad voltage regulator is enabled, and the device speed when in device mode. By defining this token to a mask comprised of the USB options mask defines usually passed as the Options parameter to <a class="el" href="group___group___u_s_b_management___a_v_r8.html#gaa6fa034a919f41e17908bdcd7d5ae151">USB_Init()</a>, the resulting compiled binary can be decreased in size by removing the dynamic options code, and replacing it with the statically set options. When defined, the <a class="el" href="group___group___u_s_b_management___a_v_r8.html#gaa6fa034a919f41e17908bdcd7d5ae151">USB_Init()</a> function no longer accepts an Options parameter.</li>
</ul>
<ul>
<li><b>USB_DEVICE_ONLY</b> - (<a class="el" href="group___group___u_s_b_management.html">USB Interface Management</a>) - <em>All Architectures</em> <br/>
 For the USB AVR models supporting both device and host USB modes, the <a class="el" href="group___group___u_s_b_management___a_v_r8.html#gaa6fa034a919f41e17908bdcd7d5ae151">USB_Init()</a> function contains a Mode parameter which specifies the mode the library should be initialized to. If only device mode is required, the code for USB host mode can be removed from the binary to save space. When defined, the <a class="el" href="group___group___u_s_b_management___a_v_r8.html#gaa6fa034a919f41e17908bdcd7d5ae151">USB_Init()</a> function no longer accepts a Mode parameter. This define is irrelevant on smaller USB AVRs which do not support host mode.</li>
</ul>
<ul>
<li><b>USB_HOST_ONLY</b> - (<a class="el" href="group___group___u_s_b_management.html">USB Interface Management</a>) - <em>All Architectures</em> <br/>
 Same as USB_DEVICE_ONLY, except the library is fixed to USB host mode rather than USB device mode. Not available on some USB AVR models.</li>
</ul>
<ul>
<li><b>USB_STREAM_TIMEOUT_MS</b>=<em>x</em> - (<a class="el" href="group___group___u_s_b_management.html">USB Interface Management</a>) - <em>All Architectures</em> <br/>
 When endpoint and/or pipe stream functions are used, by default there is a timeout between each transfer which the connected device or host must satisfy, or the stream function aborts the remaining data transfer. This token may be defined to a non-zero 16-bit value to set the timeout period for stream transfers, specified in milliseconds. If not defined, the default value specified in LowLevel.h is used instead.</li>
</ul>
<ul>
<li><b>NO_LIMITED_CONTROLLER_CONNECT</b> - (<a class="el" href="group___group___events.html">USB Events</a>) - <em>AVR8 Only</em> <br/>
 On the smaller USB AVRs, the USB controller lacks VBUS events to determine the physical connection state of the USB bus to a host. In lieu of VBUS events, the library attempts to determine the connection state via the bus suspension and wake up events instead. This however may be slightly inaccurate due to the possibility of the host suspending the bus while the device is still connected. If accurate connection status is required, the VBUS line of the USB connector should be routed to an AVR pin to detect its level, so that the USB_DeviceState global can be accurately set and the <a class="el" href="group___group___events.html#gaeff97648c9250a3d398bb0b74f040899">EVENT_USB_Device_Connect()</a> and <a class="el" href="group___group___events.html#gae88405d14d8d6dada9313520cb1501ec">EVENT_USB_Device_Disconnect()</a> events manually raised by the RAISE_EVENT macro. When defined, this token disables the library's auto-detection of the connection state by the aforementioned suspension and wake up events.</li>
</ul>
<ul>
<li><b>NO_SOF_EVENTS</b> - (<a class="el" href="group___group___events.html">USB Events</a>) - <em>All Architectures</em> <br/>
 By default, there exists a LUFA application event for the start of each USB frame while the USB bus is not suspended in either host or device mode. This event can be selectively enabled or disabled by calling the appropriate device or host mode function. When this compile time token is defined, the ability to receive USB Start of Frame events via the <a class="el" href="group___group___events.html#gaa3ebb4fd4403f463b300b745d8485b65">EVENT_USB_Device_StartOfFrame()</a> or <a class="el" href="group___group___events.html#ga5d2d69b62ab03dfaa5ac4f9591210106">EVENT_USB_Host_StartOfFrame()</a> events is removed, reducing the compiled program's binary size.</li>
</ul>
<h1><a class="anchor" id="Sec_TokenSummary_USBDeviceTokens"></a>
USB Device Mode Driver Related Tokens</h1>
<p>This section describes compile tokens which affect USB driver stack of the LUFA library when used in Device mode.</p>
<ul>
<li><b>USE_RAM_DESCRIPTORS</b> - (<a class="el" href="group___group___std_descriptors.html">USB Descriptors</a>) - <em>AVR8 Only</em> <br/>
 Define this token to indicate to the USB driver that all device descriptors are stored in RAM, rather than being located in any one of the AVR's memory spaces. RAM descriptors may be desirable in applications where the descriptors need to be modified at runtime.</li>
</ul>
<ul>
<li><b>USE_FLASH_DESCRIPTORS</b> - (<a class="el" href="group___group___std_descriptors.html">USB Descriptors</a>) - <em>AVR8 Only</em> <br/>
 Similar to USE_RAM_DESCRIPTORS, but all descriptors are stored in the AVR's FLASH memory rather than RAM.</li>
</ul>
<ul>
<li><b>USE_EEPROM_DESCRIPTORS</b> - (<a class="el" href="group___group___std_descriptors.html">USB Descriptors</a>) - <em>AVR8 Only</em> <br/>
 Similar to USE_RAM_DESCRIPTORS, but all descriptors are stored in the AVR's EEPROM memory rather than RAM.</li>
</ul>
<ul>
<li><b>NO_INTERNAL_SERIAL</b> - (<a class="el" href="group___group___std_descriptors.html">USB Descriptors</a>) - <em>All Architectures</em> <br/>
 Some AVR models contain a unique serial number which can be used as the device serial number, while in device mode. This allows the host to uniquely identify the device regardless of if it is moved between USB ports on the same computer, allowing allocated resources (such as drivers, COM Port number allocations) to be preserved. This is not needed in many apps, and so the code that performs this task can be disabled by defining this option and passing it to the compiler via the -D switch.</li>
</ul>
<ul>
<li><b>FIXED_CONTROL_ENDPOINT_SIZE</b>=<em>x</em> - (<a class="el" href="group___group___endpoint_management.html">Endpoint Management</a>) - <em>All Architectures</em> <br/>
 By default, the library determines the size of the control endpoint (when in device mode) by reading the device descriptor. Normally this reduces the amount of configuration required for the library, allows the value to change dynamically (if descriptors are stored in EEPROM or RAM rather than flash memory) and reduces code maintenance. However, this token can be defined to a non-zero value instead to give the size in bytes of the control endpoint, to reduce the size of the compiled binary.</li>
</ul>
<ul>
<li><b>DEVICE_STATE_AS_GPIOR</b> - (<a class="el" href="group___group___device.html">Device Management</a>) - <em>AVR8 Only</em> <br/>
 One of the most frequently used global variables in the stack is the USB_DeviceState global, which indicates the current state of the Device State Machine. To reduce the amount of code and time required to access and modify this global in an application, this token may be defined to a value between 0 and 2 to fix the state variable into one of the three general purpose IO registers inside the AVR reserved for application use. When defined, the corresponding GPIOR register should not be used within the user application except implicitly via the library APIs.</li>
</ul>
<ul>
<li><b>FIXED_NUM_CONFIGURATIONS</b>=<em>x</em> - (<a class="el" href="group___group___device.html">Device Management</a>) - <em>All Architectures</em> <br/>
 By default, the library determines the number of configurations a USB device supports by reading the device descriptor. This reduces the amount of configuration required to set up the library, and allows the value to change dynamically (if descriptors are stored in EEPROM or RAM rather than flash memory) and reduces code maintenance. However, this value may be fixed via this token in the project makefile to reduce the compiled size of the binary at the expense of flexibility.</li>
</ul>
<ul>
<li><b>CONTROL_ONLY_DEVICE</b> - (<a class="el" href="group___group___device.html">Device Management</a>) - <em>All Architectures</em> <br/>
 In some limited USB device applications, there are no device endpoints other than the control endpoint; i.e. all device communication is through control endpoint requests. Defining this token will remove several features related to the selection and control of device endpoints internally, saving space. Generally, this is usually only useful in (some) bootloaders and is best avoided.</li>
</ul>
<ul>
<li><b>MAX_ENDPOINT_INDEX</b> - (<a class="el" href="group___group___device.html">Device Management</a>) - <em>XMEGA Only</em> <br/>
 Defining this value to the highest index (not address - this excludes the direction flag) endpoint within the device will restrict the number of FIFOs created internally for the endpoint buffers, reducing the total RAM usage.</li>
</ul>
<ul>
<li><b>INTERRUPT_CONTROL_ENDPOINT</b> - (<a class="el" href="group___group___u_s_b_management.html">USB Interface Management</a>) - <em>All Architectures</em> <br/>
 Some applications prefer to not call the <a class="el" href="group___group___u_s_b_management.html#gac4059f84a2fc0b926c31868c744f5853">USB_USBTask()</a> management task regularly while in device mode, as it can complicate code significantly. Instead, when device mode is used this token can be passed to the library via the -D switch to allow the library to manage the USB control endpoint entirely via USB controller interrupts asynchronously to the user application. When defined, <a class="el" href="group___group___u_s_b_management.html#gac4059f84a2fc0b926c31868c744f5853">USB_USBTask()</a> does not need to be called when in USB device mode.</li>
</ul>
<ul>
<li><b>NO_DEVICE_REMOTE_WAKEUP</b> - (<a class="el" href="group___group___device.html">Device Management</a>) - <em>All Architectures</em> <br/>
 Many devices do not require the use of the Remote Wakeup features of USB, used to wake up the USB host when suspended. On these devices, the code required to manage device Remote Wakeup can be disabled by defining this token and passing it to the library via the -D switch.</li>
</ul>
<ul>
<li><b>NO_DEVICE_SELF_POWER</b> - (<a class="el" href="group___group___device.html">Device Management</a>) - <em>All Architectures</em> <br/>
 USB devices may be bus powered, self powered, or a combination of both. When a device can be both bus powered and self powered, the host may query the device to determine the current power source, via <a class="el" href="group___group___device.html#ga5ededa649292447601207825561c5ad6">USB_Device_CurrentlySelfPowered</a>. For solely bus powered devices, this global and the code required to manage it may be disabled by passing this token to the library via the -D switch.</li>
</ul>
<h1><a class="anchor" id="Sec_TokenSummary_USBHostTokens"></a>
USB Host Mode Driver Related Tokens</h1>
<p>This section describes compile tokens which affect USB driver stack of the LUFA library when used in Host mode.</p>
<ul>
<li><b>HOST_STATE_AS_GPIOR</b> - (<a class="el" href="group___group___host.html">Host Management</a>) - <em>AVR8 Only</em> <br/>
 One of the most frequently used global variables in the stack is the USB_HostState global, which indicates the current state of the Host State Machine. To reduce the amount of code and time required to access and modify this global in an application, this token may be defined to a value between 0 and 2 to fix the state variable into one of the three general purpose IO registers inside the AVR reserved for application use. When defined, the corresponding GPIOR register should not be used within the user application except implicitly via the library APIs.</li>
</ul>
<ul>
<li><b>USB_HOST_TIMEOUT_MS</b>=<em>x</em> - (<a class="el" href="group___group___host.html">Host Management</a>) - <em>All Architectures</em> <br/>
 When a control transfer is initiated in host mode to an attached device, a timeout is used to abort the transfer if the attached device fails to respond within the timeout period. This token may be defined to a non-zero 16-bit value to set the timeout period for control transfers, specified in milliseconds. If not defined, the default value specified in <a class="el" href="_host_8h.html" title="Common USB Host definitions for all architectures.">Host.h</a> is used instead.</li>
</ul>
<ul>
<li><b>HOST_DEVICE_SETTLE_DELAY_MS</b>=<em>x</em> - (<a class="el" href="group___group___host.html">Host Management</a>) - <em>All Architectures</em> <br/>
 Some devices require a delay of up to 5 seconds after they are connected to VBUS before the enumeration process can be started, or they will fail to enumerate correctly. By placing a delay before the enumeration process, it can be ensured that the bus has settled back to a known idle state before communications occur with the device. This token may be defined to a 16-bit value to set the device settle period, specified in milliseconds. If not defined, the default value specified in <a class="el" href="_host_8h.html" title="Common USB Host definitions for all architectures.">Host.h</a> is used instead.</li>
</ul>
<ul>
<li><b>INVERTED_VBUS_ENABLE_LINE</b> - (<a class="el" href="group___group___host.html">Host Management</a>) - <em>All Architectures</em> <br/>
 If enabled, this will indicate that the USB target VBUS line polarity is inverted; i.e. it should be pulled low to enable VBUS to the target, and pulled high to stop the target VBUS generation. <br/>
 <dl class="section attention"><dt>Attention</dt><dd>On AVR8 architecture devices, this compile time option requires <code>NO_AUTO_VBUS_MANAGEMENT</code> to be set.</dd></dl>
</li>
<li><b>NO_AUTO_VBUS_MANAGEMENT</b> - (<a class="el" href="group___group___host.html">Host Management</a>) - <em>All Architectures</em> <br/>
 Disables the automatic management of VBUS to the target, i.e. automatic shut down in the even of an overcurrent situation. When enabled, VBUS is enabled while the USB controller is initialized in USB Host mode. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->

	<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
		<ul>
			<li class="footer" style="float:left !important;">
				Generated by
				<a href="http://www.doxygen.org/index.html">
					<img class="footer" src="doxygen.png" alt="doxygen"/>
				</a>
				1.8.3.1
			</li>
			<li class="footer">
				<a href="http://www.lufa-lib.org" title="LUFA Project Page">LUFA Project Page</a> | <a href="http://www.lufa-lib.org/support" title="LUFA Support List">Support Mailing List</a> | <a href="http://www.lufa-lib.org/donate" title="Donate to Support LUFA">Donate</a> | <a href="http://www.fourwalledcubicle.com" title="Four Walled Cubicle Website">Four Walled Cubicle</a> - LUFA, the Lightweight USB Framework for AVRs
			</li>
		</ul>
	</div>
	</body>
</html>
