Not all Platforms support Hotplug Support,

Devise a system that Checks for Hotplug Support, and then uses either
A) Hotplug Support,
b) Timer Support


Test The Ucon64 --multi argument for what happens when DSP1 game is used in the menu.


int ROM_t::QueryUSBRomHeader()
{
    // GET THE ROM HEADER INFO

    //STEPS
    // 1. Get the ROM ENTRY
    // 2. Verify the values
    // 3. BRANCH



    uchar *bootLoaderGameEntry = DownloadBootLoaderRomEntry();


    if (!VerifyBootLoaderRomEntry(bootLoaderGameEntry))
    {
        fprintf(stderr, "WTF!! BootLoader Entry is invalid!!\n");

        QMessageBox::warning(NULL, "UH OH", "Super Flash Bootloader Game Entry Table appears invalid. \nLet's Start from Scratch!");
        //deformed_header = true;
        isAlreadyOnCart = false;
        exists = false;
        return -3;
    }

    uchar flags1 = bootLoaderGameEntry[0x1d];

    for (int i=0; i < 0x20; i++)
    {
        fprintf (stderr, "\\x%2x",bootLoaderGameEntry[i]);
    }


    if (num == 1 && bootLoaderGameEntry[0] != 0xff)
    {
        QMessageBox::warning(NULL, "UH OH", "Super Flash Bootloader Game Entry Table appears invalid. \nLet's Start from Scratch!");
        //deformed_header = true;
        isAlreadyOnCart = false;
        exists = false;
        return -2;
    }

    if (bootLoaderGameEntry[0] == 0x0 || bootLoaderGameEntry[0] != 0xFF ||
            (bootLoaderGameEntry[0] == 0xFF && ::zero_found) )
    {
        exists = false;
        //deformed_header = true;
        isAlreadyOnCart = false;

        if (bootLoaderGameEntry[0] == 0x0)
            ::zero_found = true;
        return -1;
    }






    if (flags1 & 0x40)
        startaddr = 0x200000;
    else if (flags1 & 0x20)
        startaddr = 0x400000;
    else if (flags1 & 0x60)
        startaddr = 0x600000;
    else startaddr = 0;



    int header_startaddr = 0x7fb0+startaddr;    // startaddr local to ROM_t

    // This refers to those pesky global variables I have floating around from PC-commandline-version
    ::aal = header_startaddr&0xff;
    ::aah = (header_startaddr&0xff00)>>8;
    ::aab = (header_startaddr&0xff0000)>>16;

    ::numbytes = 0x50;    // Header Size from 0x7fb0-0x7fff

    QByteArray loromheader,hiromheader, *selectedheader;
    ReadHeader(&loromheader);

    header_startaddr = 0xffb0+startaddr;
    ::aal = header_startaddr&0xff;
    ::aah = (header_startaddr&0xff00)>>8;
    ::aab = (header_startaddr&0xff0000)>>16;

    ::numbytes = 0x50;
    ReadHeader(&hiromheader);

    bool hirom= isHirom2((uchar*)loromheader.data(), (uchar*)hiromheader.data());

    if (hirom)
    {
        selectedheader = &hiromheader;
    }
    else
    {
        selectedheader = &loromheader;
    }



    for (uchar i=0; i < 21; i++)
    {
        RomTitle[i] = selectedheader->at(0x10+i);
        if (!RomTitle[i].isPrint())
            RomTitle[i] = '.';
    }

    RomTitle = RomTitle.toUpper();

    // ROM Title All set
    CartTypeByte = selectedheader->at(0x16+0x10);
    // CartTypeByteToStr
    if (CartTypeMap.contains(CartTypeByte))
        CartTypeStr = QString(CartTypeMap[CartTypeByte]);
    else CartTypeStr = QString("Unknown Cart Type");

    // Get ROM Size
    RomSizeByte = selectedheader->at(0x17+0x10);


    // Get SRAM Size
    SramSizeByte = selectedheader->at(0x18+0x10);



    if (isValid() && isTypical())
    {
        isAlreadyOnCart = true;
        exists = true;
        setString();
    }
    else
    {
        setString("Game may be Empty/Corrupt. Or it may have a very unique ROM header. I'll display the ROM info anyways:", PREPEND);
    }



    return 0;
}
